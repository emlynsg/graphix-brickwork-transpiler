"""Graphix Transpiler from circuit to MBQC patterns via brickwork decomposition.

Copyright (C) 2025, QAT team (ENS-PSL, Inria, CNRS).
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from math import pi
from typing import TYPE_CHECKING, TypeAlias

import numpy as np
from graphix import Pattern, instruction
from graphix.command import E
from graphix.instruction import InstructionKind
from graphix.parameter import ExpressionOrFloat
from graphix.transpiler import Circuit, TranspileResult
from graphix_jcz_transpiler import (
    CZ,
    J,
    JCZInstructionKind,
    decompose_ccx,
    decompose_rx,
    decompose_ry,
    decompose_rz,
    decompose_rzz,
    decompose_swap,
    decompose_y,
    j_commands,
)

if TYPE_CHECKING:
    from collections.abc import Sequence

    from graphix.transpiler import Circuit

# TODO @emlynsg: Create function to trim zero bricks from the start and end  # noqa: FIX002, TD003
# TODO @emlynsg: simplifcation to remove consecutive J(0) in decomposition  # noqa: FIX002, TD003


Angle: TypeAlias = ExpressionOrFloat

JCNOTInstruction: TypeAlias = (
    J
    | CZ
    | instruction.CNOT
    | instruction.RZZ
    | instruction.SWAP
    | instruction.H
    | instruction.S
    | instruction.X
    | instruction.Y
    | instruction.Z
    | instruction.I
    | instruction.RX
    | instruction.RY
    | instruction.RZ
    | instruction.CCX
)


class Brick(ABC):
    """Abstract base class for bricks in a brickwork state (currently CNOT and single-qubit pairs).

    Attributes
    ----------
    is_filled : bool
        Indicates if the brick is filled (true) or not (false).

    Methods
    -------
    measures() -> list[list[float]]:
        Returns the measurement angles for the brick. The sublists correspond to the top and bottom qubits in the brick.

    """

    def __init__(self) -> None:
        """Initialize the Brick object."""
        self.is_filled: bool = False

    @abstractmethod
    def measures(self) -> list[list[Angle]]: ...  # noqa: D102
    """Returns the measurement angles for the brick. The sublists correspond to the top and bottom qubits in the brick."""


@dataclass
class CNOTBrick(Brick):
    """Represents a CNOT gate in a brickwork state.

    Attributes
    ----------
    target_above : bool
        Indicates if the target qubit is above the control qubit (true) or not (false).

    Methods
    -------
    measures() -> list[list[float]]:
        Returns the measurement angles for the CNOT gate.

    """

    target_above: bool
    is_filled: bool = True

    def measures(self) -> list[list[Angle]]:
        """Return the measurement angles for the CNOT gate.

        Returns
        -------
        list[list[float]]
            A list containing two sublists, each with four measurement angles for the top and bottom qubits.

        """
        if self.target_above:
            return [[0, np.pi / 2, 0, -np.pi / 2], [0, 0, np.pi / 2, 0]]
        return [[0, 0, np.pi / 2, 0], [0, np.pi / 2, 0, -np.pi / 2]]


@dataclass
class SingleQubit:
    """Represents a single-qubit gate in a brickwork state, which can be decomposed into Rz-Rx-Rz rotations (i.e. four J(theta) operations).

    Attributes
    ----------
    angles : list[Angle] | list[None]
        The angles of J operations in the single qubit.

    Methods
    -------
    measures() -> list[float]:
        Returns the measurement angles for the single-qubit gate.

    is_identity() -> bool:
        Checks if the gate is an identity operation (no rotations).

    add(operations: list[J]) -> None:
        Adds a set of J operations to the gate.

    """

    is_filled: bool = False

    def __init__(self, angles: list[Angle] | None = None) -> None:
        """Initialize the SingleQubit object with the specified angles of J operations, or as the identity."""
        if angles is None:
            angles = [0.0, 0.0, 0.0, 0.0]
        self.angles = angles

    def measures(self) -> list[Angle]:
        """Return the measurement angles for the single-qubit gate.

        Returns
        -------
        list[float]
            A list containing four measurement angles for the single-qubit gate.

        """
        return list(self.angles)

    def add(self, operations: list[J]) -> None:
        """Add a set of J operations to the half brick.

        Parameters
        ----------
        operations : list[J]
            A list of J operations to add to the half brick.

        """
        self.angles = [j.angle for j in operations]
        self.is_filled = True


@dataclass
class SingleQubitPairBrick(Brick):
    """Represents operations on a pair of single-qubits in a brickwork state.

    Attributes
    ----------
    top : SingleQubit
        The single-qubit on the top of the brick.
    bottom : SingleQubit
        The single-qubit on the bottom of the brick.

    Methods
    -------
    get(position: bool) -> SingleQubit:
        Returns the SingleQubit at the specified position (True for bottom, False for top).

    measures() -> list[list[float]]:
        Returns the measurement angles for both single-qubits in the brick.

    """

    def __init__(self) -> None:
        """Initialize the SingleQubitPairBrick with two empty SingleQubit objects."""
        self.top = SingleQubit()
        self.bottom = SingleQubit()

    def get(self, is_bottom: bool) -> SingleQubit:  # noqa: FBT001
        """Return the SingleQubit at the specified position (True for bottom, False for top).

        Parameters
        ----------
        is_bottom : bool
            True for bottom qubit, False for top qubit.

        Returns
        -------
        SingleQubit
            The SingleQubit at the specified position.

        """
        if is_bottom:
            return self.bottom
        return self.top

    def measures(self) -> list[list[Angle]]:
        """Return the measurement angles for both single-qubits in the brick.

        Returns
        -------
        list[list[float]]
            A list containing two sublists, each with four measurement angles for the top and bottom qubits.

        """
        return [self.top.measures(), self.bottom.measures()]

    def add(self, operations: list[J], is_bottom: bool) -> None:  # noqa: FBT001
        """Add a set of J operations to the gate.

        Parameters
        ----------
        operations : list[J]
            A list of J operations to add to the gate.
        is_bottom : bool
            True for bottom qubit, False for top qubit.

        """
        if is_bottom:
            self.bottom.add(operations)
        else:
            self.top.add(operations)
        self.is_filled = self.top.is_filled and self.bottom.is_filled


def create_identity_brick() -> SingleQubitPairBrick:
    """Create a SingleQubitPairBrick representing identity operations on both qubits.

    Returns
    -------
    SingleQubitPairBrick
        A SingleQubitPairBrick with identity operations on both qubits.

    """
    return SingleQubitPairBrick()


@dataclass
class Layer:
    """Represents a layer in a brickwork state.

    In MBQC notation the layer is a vertical stack of bricks, where even bricks are entangled on column 3 mod 8 and odd bricks on 5 mod 8.
    In the case of an odd number of qubits, the layer does not include the half-brick.

    ref: A. Broadbent, J. Fitzsimons, and E. Kashefi, 2009 50th annual IEEE symposium on foundations of computer science. IEEE. (2009).

    Attributes
    ----------
    is_odd : bool
        Indicates if the layer is odd (True) or even (False) in the brickwork pattern.
    bricks : list[Brick]
        The list of bricks in the layer.

    Methods
    -------
    get(qubit: int) -> tuple[Brick, bool]:
        Returns the brick and position in the brick (True for bottom, False for top) for the specified qubit.

    """

    is_odd: bool
    bricks: list[Brick]

    def get(self, qubit: int) -> tuple[Brick, bool]:
        """Return the brick and position in the brick (True for bottom, False for top) for the specified qubit.

        Parameters
        ----------
        qubit : int
            The index of the qubit to retrieve the brick for.

        Returns
        -------
        tuple[Brick, bool]
            A tuple containing the Brick and a boolean indicating the position (False for top, True for bottom).

        """
        index = (qubit - int(self.is_odd)) // 2
        return (self.bricks[index], bool(qubit % 2) != self.is_odd)


def __get_layer(width: int, layers: list[Layer], depth: int) -> Layer:
    """Initialize next required layer(s) as identity operators.

    Parameters
    ----------
    width : int
        number of qubits in the circuit
    layers : list[Layer]
        list of current layers in brickwork
    depth : int
        starting depth of the layer(s) to create and the layer to return

    Returns
    -------
    Layer
        the layer at the specified depth

    """
    for i in range(len(layers), depth + 1):
        odd = bool(i % 2)
        layer_size = (width - 1) // 2 if odd else max(width // 2, 1)
        layers.append(
            Layer(
                odd,
                [create_identity_brick() for _ in range(layer_size)],
            )
        )
    return layers[depth]


def __insert_single_qubit(
    width: int,
    layers: list[Layer],
    depth: list[int],
    instr: list[J],
) -> None:
    """Insert a single qubit operation into the brickwork.

    Parameters
    ----------
    width : int
        number of qubits in the circuit
    layers : list[Layer]
        list of current layers in brickwork
    depth : list[int]
        list of how many bricks deep each qubit is
    instr : list[J]
        the single qubit instruction to insert as a set of four J gates

    """
    qubit_index = instr[0].target
    target_depth = depth[qubit_index]
    if (qubit_index == 0 and target_depth % 2) or (
        width >= 2 and qubit_index == width - 1 and target_depth % 2 != width % 2  # noqa: PLR2004
    ):
        target_depth += 1  # Ensure the operation skips past the half-brick.
    layer = __get_layer(width, layers, target_depth)
    brick, is_bottom = layer.get(qubit_index)
    assert isinstance(brick, SingleQubitPairBrick)  # noqa: S101
    assert not brick.is_filled  # noqa: S101
    single_qubit = brick.get(is_bottom)
    assert not single_qubit.is_filled  # noqa: S101
    single_qubit.add(instr)
    depth[qubit_index] = target_depth + 1


def __insert_cnot(
    width: int,
    layers: list[Layer],
    depth: list[int],
    instr: instruction.CNOT,
) -> None:
    """Insert a CNOT as a brick into the brickwork layers.

    Parameters
    ----------
    width : int
        number of qubits in the circuit
    layers : list[Layer]
        list of current layers in brickwork
    depth : list[int]
        list of how many bricks deep each qubit is
    instr : instruction.CNOT
        the CNOT instruction to insert

    Raises
    ------
    ValueError
        if the control and target qubits are not consecutive

    """
    if abs(instr.control - instr.target) != 1:
        raise ValueError("Unsupported CNOT: control and target qubits should be consecutive")
    top_qubit_index = min(instr.control, instr.target)  # Chooses top qubit for indexation purposes
    bottom_qubit_index = max(instr.control, instr.target)
    min_depth = max(depth[top_qubit_index], depth[bottom_qubit_index])  # Ensures the operation is late enough (e.g. top qubit could be 2 deep already)
    target_depth = min_depth if top_qubit_index % 2 == min_depth % 2 else min_depth + 1
    layer = __get_layer(width, layers, target_depth)
    index = top_qubit_index // 2
    layer.bricks[index] = CNOTBrick(top_qubit_index == instr.target)
    depth[top_qubit_index] = target_depth + 1
    depth[bottom_qubit_index] = target_depth + 1


def decompose_h(instr: instruction.H) -> Sequence[J]:
    """Return a decomposition of the Hadamard gate for the brickwork as 3 rotations.

    Broadbent et al. (2009) decomposition of the Hadamard gate in the brickwork.

    Args:
    ----
        instr: the Hadamard instruction to decompose.

    Returns:
    -------
        the decomposition as a list.

    """
    return [J(instr.target, pi / 2), J(instr.target, pi / 2), J(instr.target, pi / 2), J(instr.target, 0)]


def decompose_cz(instr: CZ) -> Sequence[instruction.H | instruction.CNOT]:
    """Return a decomposition of the CNOT gate as H·∧x·H.

    Based on the common CNOT decomposition H·∧z·H.

    Args:
    ----
        instr: the CZ instruction to decompose.

    Returns:
    -------
        the decomposition.

    """
    return [
        instruction.H(instr.targets[0]),
        instruction.CNOT(control=instr.targets[1], target=instr.targets[0]),
        instruction.H(instr.targets[0]),
    ]


def _cnot_is_local(cnot: instruction.CNOT) -> bool:
    return abs(cnot.control - cnot.target) == 1


def decompose_cnot(instr: instruction.CNOT) -> Sequence[instruction.CNOT]:
    """Return a decomposition of the CNOT gate as 4 CNOTs if indices are separate."""
    if _cnot_is_local(instr):
        return [instr]
    qubit_indices = [instr.control, instr.target]
    target_is_lower = bool(qubit_indices.index(min(qubit_indices)))
    if target_is_lower:
        return [instruction.CNOT(target=instr.target, control=instr.control - 1),
                instruction.CNOT(target=instr.control - 1, control=instr.control),
                instruction.CNOT(target=instr.target, control=instr.control - 1),
                instruction.CNOT(target=instr.control - 1, control=instr.control)]
    return [instruction.CNOT(target=instr.target - 1, control=instr.control),
            instruction.CNOT(target=instr.target, control=instr.target - 1),
            instruction.CNOT(target=instr.target - 1, control=instr.control),
            instruction.CNOT(target=instr.target, control=instr.target - 1)]


def instruction_to_jcnot(instr: JCNOTInstruction) -> Sequence[instruction.CNOT | list[J] | None]:  # noqa: C901
    """Return a decomposition of the instruction.

    Instructions are purposefully extended to sets of 4, to isolate each operation to a single brick or sequence of complete bricks.

    Args:
    ----
        instr: the instruction to decompose.

    Returns:
    -------
        the decomposition.

    """
    # Use == for mypy
    if instr.kind == InstructionKind.CNOT:  # Checked
        return instruction_list_to_jcnot(decompose_cnot(instr))
    if instr.kind == InstructionKind.I:  # Checked
        return [None]
    if instr.kind == InstructionKind.H:  # Checked
        return instruction_list_to_jcnot(decompose_h(instr))
    if instr.kind == InstructionKind.S:  # Checked
        return instruction_to_jcnot(instruction.RZ(instr.target, pi / 2))
    if instr.kind == InstructionKind.X:  # Checked
        return instruction_to_jcnot(instruction.RX(instr.target, pi))
    if instr.kind == InstructionKind.Y:  # Checked
        return instruction_list_to_jcnot(decompose_y(instr))
    if instr.kind == InstructionKind.Z:  # Checked
        return instruction_to_jcnot(instruction.RZ(instr.target, pi))
    if instr.kind == InstructionKind.RX:  # Checked
        x_decomp: list[J] = list(decompose_rx(instr))
        x_decomp.extend([J(instr.target, 0), J(instr.target, 0)])
        return [x_decomp]
    if instr.kind == InstructionKind.RY:  # Checked
        return [list(decompose_ry(instr))]
    if instr.kind == InstructionKind.RZ:  # Checked
        z_decomp: list[J] = list(decompose_rz(instr))
        z_decomp.extend([J(instr.target, 0), J(instr.target, 0)])
        return [z_decomp]
    if instr.kind == InstructionKind.CCX:
        return instruction_list_to_jcnot(decompose_ccx(instr))
    if instr.kind == InstructionKind.RZZ:
        return instruction_list_to_jcnot(decompose_rzz(instr))
    if instr.kind == InstructionKind.SWAP:
        return instruction_list_to_jcnot(decompose_swap(instr))
    if instr.kind == JCZInstructionKind.J:  # Checked
        raise ValueError("J instructions should not be decomposed.")
    if instr.kind == JCZInstructionKind.CZ:  # Checked
        return instruction_list_to_jcnot(decompose_cz(instr))  # pyright: ignore[reportArgumentType]
    raise ValueError(f"Unknown instruction kind: {instr.kind}")


def instruction_list_to_jcnot(instrs: Sequence[JCNOTInstruction]) -> Sequence[instruction.CNOT | list[J] | None]:
    """Return a J-∧z decomposition of the sequence of instructions.

    Args:
    ----
        instrs: the instruction sequence to decompose.

    Returns:
    -------
        the decomposition.

    """
    return [jcnot_instr for instr in instrs for jcnot_instr in instruction_to_jcnot(instr)]


def transpile_to_layers(circuit: Circuit) -> list[Layer]:
    """Transpile a circuit into a list of brickwork layers.

    Parameters
    ----------
    circuit : Circuit
        the circuit to transpile

    Returns
    -------
    list[Layer]
        the list of layers representing the brickwork state

    """
    layers: list[Layer] = []
    depth = [0 for _ in range(circuit.width)]
    for instr in circuit.instruction:
        # Use of `if` instead of `match` here for mypy
        if instr.kind == InstructionKind._XC or instr.kind == InstructionKind._ZC or instr.kind == InstructionKind.M:  # noqa: PLR1714
            raise ValueError(f"Unsupported instruction: {instr}")
        for instr_jcnot in instruction_to_jcnot(instr):
            if instr_jcnot is None:  # Checking for identity operations
                continue
            if isinstance(instr_jcnot, list):  # Checking for J gates
                assert len(instr_jcnot) == 4  # noqa: PLR2004, S101
                __insert_single_qubit(circuit.width, layers, depth, instr_jcnot)
                continue
            if instr_jcnot.kind == InstructionKind.CNOT:  # Checking for CNOT
                assert isinstance(instr_jcnot, JCNOTInstruction)  # noqa: S101
                cnot: instruction.CNOT = instr_jcnot
                __insert_cnot(circuit.width, layers, depth, cnot)
            else:
                raise ValueError(f"Unexpected instruction: {instr_jcnot}")
    return layers


class ConstructionOrder(Enum):
    """Enumeration of construction orders for building MBQC measurement patterns from a measurement table.

    Values are used by `typer` in the command-line interface.
    """

    Canonical = "canonical"
    Deviant = "deviant"
    DeviantRight = "deviant-right"


def nqubits_from_layers(layers: list[Layer]) -> int:
    """Return the number of qubits represented by the given layers.

    Parameters
    ----------
    layers : list[Layer]
        the list of layers representing the brickwork state

    Returns
    -------
    int
        the number of qubits represented by the layers

    Raises
    ------
    ValueError
        if the layer list is empty

    """
    if len(layers) == 0:
        raise ValueError("Layer list should not be empty")
    if len(layers) == 1:
        return 2 * len(layers[0].bricks)
    even_brick_count = len(layers[0].bricks)
    odd_brick_count = len(layers[1].bricks)
    return even_brick_count * 2 + int(even_brick_count == odd_brick_count)


def layers_to_measurement_table(layers: list[Layer]) -> list[list[Angle]]:
    """Convert layers of bricks into a measurement table.

    Goes left to right in measurement order, .

    Parameters
    ----------
    layers : list[Layer]
        the list of layers representing the brickwork state

    Returns
    -------
    list[list[Angle]]

    """
    nqubits: int = nqubits_from_layers(layers)
    table: list[list[Angle]] = []
    for layer_index, layer in enumerate(layers):
        all_brick_measures = [brick.measures() for brick in layer.bricks]  # Should be a list of two lists of four floats, one for each qubit (top, bottom) in the brick
        for column_index in range(4):
            column: list[Angle] = []
            if layer.is_odd:
                column.append(0)  # Add zero angle for the half brick
            column.extend(
                measures[i][column_index]
                for measures in all_brick_measures
                for i in (0, 1)
            )
            if layer_index % 2 != nqubits % 2:
                column.append(0)
            table.append(column)
    return table


def measurement_table_to_pattern(width: int, table: list[list[Angle]]) -> Pattern:
    """Convert a measurement table into a MBQC measurement pattern.

    This function constructs the measurement pattern.

    Parameters
    ----------
    width : int
        number of qubits in the circuit
    table : list[list[Angle]]
        the measurement table, where each sublist represents a column of measurement angles

    Returns
    -------
    Pattern
        the resulting MBQC measurement pattern

    """
    nodes = list(range(width))
    n_nodes = width
    pattern = Pattern(input_nodes=nodes)  # Initialise with input nodes
    for column_index, column in enumerate(table):
        for qubit, angle in enumerate(column):
            pattern.extend(j_commands(nodes[qubit], n_nodes, angle))
            if (column_index % 4 in {2, 0} and column_index > 0):
                brick_layer = (column_index - 1) // 4
                if qubit % 2 == brick_layer % 2 and qubit != width - 1:
                    pattern.add(
                        E(nodes=(nodes[qubit], nodes[qubit + 1]))
                    )
            nodes[qubit] = n_nodes
            n_nodes += 1
    return pattern


def layers_to_pattern(width: int, layers: list[Layer], order: ConstructionOrder = ConstructionOrder.Canonical) -> Pattern:  # noqa: ARG001
    """Convert layers of bricks into a MBQC measurement pattern.

    This is a convenience function that combines `layers_to_measurement_table` and `measurement_table_to_pattern`.

    Parameters
    ----------
    width : int
        number of qubits in the circuit
    layers : list[Layer]
        the list of layers representing the brickwork state
    order : ConstructionOrder, optional
        the construction order to use for building the pattern, by default ConstructionOrder.Canonical

    Returns
    -------
    Pattern
        the resulting MBQC measurement pattern

    """
    table = layers_to_measurement_table(layers)
    return measurement_table_to_pattern(width, table)


def transpile_brickwork(circuit: Circuit, order: str = "canonical") -> TranspileResult:
    """Transpile the circuit to a brickwork pattern defined in the Universal Blind Quantum Computation.

    Parameters
    ----------
    circuit : Circuit
        the circuit to transpile, which should contain only CNOT, RX and RZ gates

    order : ConstructionOrder
        Order in which to construct the brickwork pattern. Default is Canonical.

    Returns
    -------
    result : :class:`TranspileResult` object

    Raises
    ------
    ValueError
        if the order is not recognized

    """
    n_node = circuit.width
    order_as_object = ConstructionOrder.Canonical
    if order == "canonical":
        pass
    elif order == "deviant":
        order_as_object = ConstructionOrder.Deviant
    elif order == "deviant-right":
        order_as_object = ConstructionOrder.DeviantRight
    else:
        msg = f"Unknown construction order: {order}. Available orders are 'canonical', 'deviant' and 'deviant-right'."
        raise ValueError(msg)
    pattern = layers_to_pattern(n_node, transpile_to_layers(circuit), order_as_object)
    classical_outputs: list[int] = []
    return TranspileResult(pattern, tuple(classical_outputs))
